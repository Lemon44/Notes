Design Patterns 01:

Chapter 1: (In class Notes)
A software design pattern is a general reusable solution to a commonly-occurring problem within a given context in software design.

It is not a finished design that can be transformed directly into source or machine code.

They're formalized best practices, object-oriented patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects taht are involved.

Why Talk about Design Patterns?
-Creates a shared vocabulary
	-Developers can interact in richer terms
-Keeps thinking/designing at the abstract (pattern) level
	-Creates better (more flexible, reusable, etc.) designs

Origin:
Patterns originated as an architectural concept by Christopher Alexander (1977/79).  
In 1987, Kent Beck and Ward Cunningham began experimenting with the idea of applying patterns to programming - specifically pattern languages - and presented their results at the OOPSLA conference that year. 

Christopher Alexander:
"father of the pattern language movement"
the first wiki - technology behind wikipedia - led directly from Alexander's work, according to its creator, Ward Cunningham 
Alexander's work has also influenced the development of the agile software development style. 
"A Pattern Language" - practical architectural system in a form that a theoretical mathematician or computer scientist might call a generative grammar. 
"The Timeless Way of Building" 
Wrote Notes on the Synthesis of Form, had an influence in the 1960's and 70's programming language design, modualr programming, object-orineted programming, and other methodologies. 

Will Wright said Alexander was influencial in building Sim City.

Groups and Concepts:
___________________________
Design patterns were originally grouped into categories:
	-Creational Patterns
	-Structrural Patterns
	-Behavioral Patterns
And described using the concepts of 
	-Delegation (making other people do things for you)
	-Aggregation (putting things together)
	-Consultation (one object consults with another object)

First Design Principle:

***There is a difference between a Principle and a Pattern (KNOW THIS!)***

Identify the aspect of your application that vary and separate them from what stays the same. 
You can alter or extend without affecting other parts.
Basis of almost every design pattern. 

Second Design Principle:

Program to an interface, not an implementation 
	-Not necessarily a Java interface
	-Program to a supertype (use the appropriate interface)
	-Can then better use polymorphism
	-Can more easily change implementation

Third Design Principle:

Favors composition over inheritance
Favor "has-a" relationships over "is-a" relationships
Inheritance limits reusability

Strategy Pattern:
______________________
-Defines a family of algorithms, encapsulates each one, and makes them interchangeable
-Strategy lets the algorithm vary independently from the clients that use it. 
-(Example: Sorting algorithms are helpful at different times)
-Behavioral

Chapter 2: (In class Notes)

The Observer Pattern:
______________________
-Defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified. 
-Object, called the subject, maintains a list of dependents, called observers, and notifies them automatically of any state changes, usually calling on of their methods. 
-It is mainly used to ijmplement distributed event handling systems, in "event driven" software. 
-The observer pattern is also a key part in the familiar model-view-controller (MVC) architectural pattern
-Behavioral
-Polymorphism is the fact that we can call a particular method to different objects***

Languages 
-Java has Observer, Observable, etc. 

Design Principle:
-Strive for loosely-coupled designs between objects that interact
-Objects have very little information about each other
-No shared state

Decoupling:
-The obsever pattern helps decouple objects
-The subject knows only that the obsever implements the Observer interface
-New observers can be added at any time
-New types of observers can be added
-Can reuse subjects and observers independently
-Changes have no affect on each other

Warnings:
-Don't depend on order of evaluation of 
**There is no guarantee that a particular observer will be called before another
-Java Observable is a class
	-Not an interface
	-Must inherit
	-setChanged() is protected