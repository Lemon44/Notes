Effective Java Notes:
Nicole Beck

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
[Chapter 2]:

Consider Static Factory Methods Instead of Constructors
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-One advantage is they have names
	-Constructors do not and one has to differentiate via parameters
	-This can be confusing and lead to errors
-A class can have only one constructor with a given name
	-Don't change order of constructor parameters to differentiate 
-Static factory methods don't have to create a new object
	-Constructors always do
	-Maybe there's an object already created that works
	-Helps with immutable classes and pre-constructed instances
-Singletons, flyweights, non-instantiable. 
-Can return a subtype
	-java.util.collections contain all static methods that work on many types
	-Polymorphic
	-addAll, binarySearch, disjoint, frequency, min, max, sort, shuffle, reverse,...
	-Type returned can be non-public
	-Can vary implementation
-Returned class need not exist at the time the class is written
	-Allows run-time specification
	-JDBC an example

Service-Provider Framework:
* * * * * * * * * * * * * *
-Service interface
-Provider registration
-Service access
-Optional service provider interface
	-Factory to create service provider

Java 6: -General-purpose java.util.ServiceLoader (So you don't have to write your own)

Disadvantages of Static Factory Methods Instead of Constructors:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-Classes without public or protected constructors cannot be sub-classed
-Not called out in Javadoc
-Popular Java static factory names
	-valueOf, getInstance, newInstance, getType,... (style guides)

Consider a Builder when faced with many Constructory Parameters (decorator):
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-If a class has many fields that need initializing, constructors often chained/telescoped
example of "telescoping":
	public class NutritionFacts {
		private final int servingSize;
		private final int servings;
		private final int calories;
		private final int fat;
		private final int sodium;
		private final int carbohydrate;
		
		public NutritionFacts(int servingSize, int servings) {
			this(servingSize, servings, 0);
		}
		public NutritionFacts(int servingSize, int servings, int calories) {
			this(servingSize, servings, calories, 0);
		} ... etc.

^^^Bad form
-You could instead create an empty instance and have many set()s
	-Problem: instance in inconsistent state
-Builder Pattern
-build() is a parameter-less static method
-Required parameters passed in to constructor
	-Optionals set()
	-Other languages have optional parameters instead
	
Example of the Builder pattern per last example:

		private int calories = 0;
		private int fat = 0;
		private int carbohydrates = 0;

		public Builder(int servingSize, int servings) {
			this.servingSize = servingSize;
			this.servings = servings;
		}
		public Builder calories(int val) {
			calories = val;
			return this; // Returns one of itself
		} ... etc.
		private NutritionFacts(Builder builder) {
			servingSize = builder.servingSize;
			servings = builder.servings;
			calories = builder.calories;
			fat = builder.fat;
			sodium = builder.sodium;
		}
		public static void main(String[] args) {
			NutritionFacts cocaCola =new NutritionFacts.Builder(240,8).
			calories(100).sodium(35).carbohydrate(27).build();
		}

Builder for Class Hierarchies:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -

New York Pizza example:

public abstract class Pizza {
	public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }
	final Set<Toppings> toppings;
	
	abstract static class Builder <T extends Builder <T>> {
		EnumSet<Topping> toppings = EnumSet.nonOf(Topping.class);
		public addTopping(Topping topping) {
			toppings.add(Objects.requireNonNull(topping));
			return self();
		}
		abstract Pizza build();
		protected abstract T self();
	}
	Pizza(Builder<?> builder... [missed it.] 

Enforce the Singleton Property with a Private Constructor or an Enum Type:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-Private No-Arg Constructor

public class Elvis {
	public static final Elvis INSTANCE = new Elvis ();
	
	private Elvis() {}

	public void leaveTheBuilding() {
		System.out.println("Whoa baby, I'm outta here!");
	}
	public static void main(String[] args) {
		Elvis elvis = Elvis.INSTANCE;
		elvis.leaveTheBuilding();
	}
}

Static Factory:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis () {}
	public static Elvis getInstance() {
		return INSTANCE;
	}

Enumeration:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
public enum Elvis {
	INSTANCE;

	public void leaveTheBuilding() {
		System.out.println("Whoa baby, I'm outta here!");
	}
	public static void main(String[] args) {
		Elvis elvis = Elvis.INSTANCE;
		elvis.leaveTheBuilding();
	}
}
Enforce Non-Instantiability with Private Constructor:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-Just have a private no-args constructor
	-If have any no-args constructor, the default isn't created
-Class cannot be sub-classed
	-Sub-classes would need to call constructory
-Might want to have constructor throw an AssertionError (Just to be safe)


***MISSED SOME THINGS***

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
[CHAPTER 3]:

So?
-There is no way to extend an instantiable class and add a value while preserving the equals contract

Consistency:
- - - - - - - - - - - - - -
-Do not wrtie an equals method that depends on unreliable resources
-Java's URL equals relies on IP address comparison
	-What happens when not on network?
	-What happens when network addresses change?

Recipe:
- - - - - - - -
-Check for object == this
-Use instanceOf to check for correct type
-Cast argument to correct type
-Test == for all significant fields
	-Except for Float.compare, Double.compare, and Arrays.equal
-Also ovverride hashCode
-Use @Override (make sure you actually are using the signature method)

Always Override hashCode when you Override equals:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-When invoked on the same object, and the object hasn't changed to affect equals, always return the same integer
	-Does not have to be the same integer from runtime to runtime
-If two objects are equals, both hashCodes must be the same
-If they are not equals, it is not required to product distinct hashCodes
	-If not, hash table performance can be affected
	-"return 42" is legal, but horrible (everything will always collide)
-Don't rely on hashcodes, sometimes unsafe. 
-Creating a hashCode (How Java does it)
	-Set result = 17
	-For all the fields
		-If boolean, c = f ? 1:0
		-If byte, char, short, or int, c = (int) f
		-If long, c = (int)(f^(f>>>32))
		-If float, c = Float.floatToIntBits(f)
		-If double, c = (int)(Double.doubleToLongBits(f)^.... **missed it**
-Update result = 31 * result + c
-Exclude any redundant fields
	-Which you shouldn't have
-Ignore any fields ignored by equals

Creating a hashCode:
- - - - - - - - - - - - - - - - - - - - - - - - -
	public final class PhoneNumber {
		private final short areaCode;
		private final short prefix;
		private final short lineNumber;
		private volatile int hashCode;

	//Lazy initialization
	@Override public int hashCode() {
	.....missed it

-If two things are .equals, their hashCodes must also be the same
	-If hashing is really fast, and equals is really slow, maybe you call them inside eachother
	-But really you have to call them both

Always Override toString:
- - - - - - - - - - - - - - - - - - - - - - - - 
	-Makes class much more pleasant to use
	-Whe practical, toString should return all interesting information in object
	-One has to choose the format returned 
		-Good idea to create a constructor or static factory that takes string representation and creates object
	-Provide access to values in toString via getters
		*lombok (toString, EqualsAnd HashCode)

Override clone Judiciously: (DON'T DO IT)
- - - - - - - - - - - - - - - - - - - - - - - - - - -
-Creates and returns a copy of an object
	-x.clone() ! = x
	-x.clone().getClass() == x.getClass()
	-x.clone().equals(x)
	-Constructors are not called
-Don't clone an immutable object
-Instead, you can provide a copy constructor or factory
-Interfaces should not extend Cloneable
-Classes designed for inheritance should not implement it

Consider Implementing Comparable:
- - - - - - - - - - - - - - - - - - - - - - - - - - -
-Similar to equals
	-But provides ordering information
	-Is generic
	-Useful in e.g. Arrays.sort()
-Returns comparison between two objects
	- -1 if first less than second
	- 0 if equal to 
	- 1 if first greater than second

Compare versus Equals:
 - - - - - - - - - - - - - - - - - - - - 
**Missed it**

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
[CHAPTER 4]:

Minimize the Accessibility of Classes and Members:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - 
-Encapsulation
-Decouples modules allowing them to be developed, tested, optimized, used, understood, and modified in isolation
-"The single most important factor that distinguishes a well-designed module from a poorly-designed one is the degree to which the module hides its internal data and other implementation details from other modules"
-Make each class or member as inaccessible as possible
-If used nowhere else, nest a class within the class that uses it
-Don't make any variable/field/attribute public
	-At worst, make it package-private
-Try to avoid protected too
	-Must always support
	-Exposes implementation detail to subclasses
	-Should be rare
-If a method overrides a superclass method, it must have the same access level
	-To not violate the Liskov inversion principle
-Implementing an interface requires all methods to be public
	-Implicit in implementing an interface
-Instance fields should never be public
	-Limits typing
	-Limits invariants
	-Are not thread-safe
-Arrays are always mutable
	-Never have a public static final array field
	-Or an accessor that retruns such a beast
	-Be careful of IDE's that create accessors automatically
**if you are returning an array, return the copy of the array, for security

In Public Classes, use Accessor Methods, not Public Fields:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
-Book still insists on using lame examples of sets instead of simply making fields public
	-With the ostensible argument that we can change internal representation
		-But we never do
		-And if we do, we break the preexisting API contract
	-Less harmful if immutable

Minimize Mutability:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
-All information provided at construction
-Any changes result in new objects
	-Which is in general true
-Don't provide methods that modify an object's state
	-Mutators
-Ensure class cannot be extended (make them final)
	-Subclasses can't change intent 
	-Unless you truly want to extend the class
-Make all fields final
-Make all fields private
-Ensure client cannot obtain references to mutable data
	-Don't use client-provided reference
	-Don't return direct object reference
	-Make defensive copies
-Immutable objects are simple
	-Always the same behavior
	-Never global data
-Immutable objects are thread-safe
	-Implicitly parallelizable
	-No synchronization needed

**Python is horrible for threading, Scala is probably the best for threading**

-Only possible downside is the need for an object for each value 
	-But: objects are in general cheap
	-Are you sure it's inefficient?
-"Classes should be immutable unless there is a very good reason to make them mutable"
	-At the very least, from an external point of view
-If cannot be immutable, limit mutability as much as possible
	-Make every field final unless there is a compelling reason not to

Favor Composition over Inheritance:
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
-GO4
-Inheritance violates encapsulation
	-Subclass depends on superclass's implementation

Implementation Details:

import Java.util.Arrays;
import Java.util.Collection;
import java.util.HashSet;

public class InstrumentedHashSet <E> extends HashSet <E> {
	private int addCount


**missed it***


Compose Instead:
- - - - - - - - - - - - - - - - - - - - - - - - - - - -
-An InstrumentedHashSet HAS A HashSet instead of extending a HashSet
	-And extends a ForwardingSet class
-Have methods forward to the referenced type
-These are WRAPPER classes
	-AKA decorator classes







